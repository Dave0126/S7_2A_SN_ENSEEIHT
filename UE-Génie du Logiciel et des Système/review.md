# mini-projet
## SimplePDL.ocl
```ocl
// 详见课件第64页

// 这里的Place对应一个类
context Place

// 设置的name由大小写字母和数字组成
inv validName('Invalid name: ' + self.name):
	self.name.matches('[A-Za-z_][A-Za-z0-9_]*')

// 两个Place的name不能相同，并报错
inv deuxNomsDiffrentsDesPlaces ('This name of Place: ' + self.name + 'is been used !'):
	Place.allInstances() 
		-> select ( p | p.name = self.name)
		-> size() = 1 // 元素的个数

// implies 可以理解为 如果...就...
	(self.a.oclIsTypeOf(A) // 如果这个对象的 a 是 A类型
		implies self.b.oclIsTypeOf(B) // 那么这个对象的 b 就是 B类型
	) and (
	...
	)

import 'SimplePDL.ecore'

package simplepdl

context Process
inv warningSeverity: false
inv withMessage('Explicit message in process ' + self.name + ' (withMessage)'): false
-- inv errorSeverity: null 



context Process
inv validName('Invalid name: ' + self.name):
	self.name.matches('[A-Za-z_][A-Za-z0-9_]*')

context ProcessElement
def: process(): Process =
	Process.allInstances()
		->select(p | p.processElements->includes(self))
		->asSequence()->first()

context WorkSequence
inv successorAndPredecessorInSameProcess('Activities not in the same process : '
		+ self.predecessor.name + ' in ' + self.predecessor.process().name+ ' and '
		+ self.successor.name + ' in ' + self.successor.process().name
):
	self.process() = self.successor.process()
	and self.process() = self.predecessor.process()			

--contraintes sur les ressources et leurs parametres 

context Ressource

	inv QtePositive:
	self.nbOccurance > 0

context parametre

	inv QtePositive:
	self.Qte >=0
		
--1. Deux activites differents n'a pas le meme nom	
context Process
inv Differences:
	self.activities() -> forAll(act1, act2 | act1 <> act2 implies act1.name <> act2.name)

--2. Dependance ne peut pas etre reflexive
context WorkSequence
inv notReflexive: 
	self.predecessor <> self.successor

--4. Le nom d'une acticite...
context Process
def: activities():
	Sequence(WorkDefinition)=
		self.processElements -> select(e|e.oclIsKindOf(WorkDefinition))
		-> collect(e|e.oclAsType(WorkDefinition))
		-> asSequence()

endpackage

```
## xtext 语法实例
定义出的语法如下：
```
datatype String

entity Blog{
    title: String
    many posts: Post
}

entity HasAuthor{
    author: String
}

entity Post extends HasAuthor{
    title: String
    content: String
    many commnets: Comment
}

entity Comment extends HasAuthor{
    content: String
}
```
1、语法中第一个规则通常作为入口或者开始的规则
```
Domainmodel:
    elements += Type*
;
```
Domainmodel包含任意数量（*）的Type，且该Type会被加到（+=）一个名为elements的特性中去。

2、Type的规则表明Type是规则DataType或者（|）规则Entity。
```
Type:
    DataType | Entity
;
```

3、规则DataType以关键字“datatype”开始，后面跟着一个标示符，该标示符被解析为规则ID，其中规则ID的定义在语法超集org.eclipse.xtext.common.Terminals中，规则ID是一个单词，即标示符。
```
DataType:
    'datatype' name = ID
;
```

4、规则Entity也是以一个关键字开头，后面跟着一个名称（name）。
```
Entity:
    'entity' name = ID ('extends' superType = [Entity])? '{'
        features += Features*
    '}'
;
```
后面是一个带有括号和可选项（？）的extends从句。因为名为superType的特性采用交叉引用（注意其中的中括弧），不对中括弧中的规则Entity进行解析，而仅仅对标示符进行解析（ID）。在链接过程中才会对Entity进行解析。最后，大括弧中可以由任意数量的Features。

5、Feature规则的定义如下：
```
Feature:
    (many ?= 'many')? name = ID ':' type = [Type]
;
```
关键字many是用来对域建模DSL中对一个多值特性进行建模，赋值操作（？=）表明特性many的类型为boolean。
改进后语法定义
```
//datatypes.dmodel

datatype String
```
```
//commons.dmodel

package my.company.common{
    entity HasAuthor{
        author: String
    }
}
```
```
//blogs.dmodel

package my.company.blog{
    import my.company.common.*
    
    entity Blog{
        title: String
        many posts: Post
    }
    
    entity Post extends my.company.commom HasAuthor{
        title: String
        content: String
        many comments: Comment
    }
    
    entity Comment extend HasAuthor{
        content: String
    }
}
```
**语法改进**
1、由于Domainmodel不但包含类型而且包含包，因此，需要对入口进行修改。此外，需要定义通用的超类型Packages和Types：AbstractElement
```
Domainmodel:
    (elements += AbstractElement)*
;
AbstractElement:
    PackagesDeclaration | Type
;
```
2、PackageDeclaration包含一系列的Imports和AbstractElements，因为Imports可以作为root-Domainmodel,所以讲Import加入到AbstractElement中
```
PackageDeclaration:
    'package' name = QualifiedName '{'
        (elements += AbstractElement)*
    '}'
;

AbstractElement:
    PackageDeclaration | Type | Import
;

QualifiedName:
    ID ('.' ID)*
```
QualifiedName有一点特殊，其不包含任何赋值。因此仅作为数据类型规则，返回一个字符串。因此Package的特性name是String类型

3、使用xtext，可以很方便的定义imports。如果在解析规则中使用ImportedNameSpace，基础结构将会视其为import，甚至支持通配符。
```
Import:
    'import' importNamespace  = QualifiedNameWithWildcard
;

QualifiedNameWithWildcard:
    QualifiedName '.*'?
;
```
同QualifiedName类似，QualifiedNameWithWildcard返回一个字符串。

4、最后一步是允许用完整的命名来交叉引用，否则，只有import之后，才能进行引用。
```
Entity:
    'entity' name = ID ('extends' superType = [Entity | QualifiedName])?
    '{'
        (features += Feature)*
    '}'
;

Feature:
    (many ?= 'many')? name = ID ':' type = [Type | QualifiedName]
;
```
## PDL.xtext
```
// automatically generated by Xtext
grammar fr.n7.simplepdl.txt.PDL with org.eclipse.xtext.common.Terminals

import "http://simplepdl" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Process returns Process:
	{Process}
	'Process'
	name=EString
	'{'
		('processElements' '{' processElements+=ProcessElement ( "," processElements+=ProcessElement)* '}' )?
		('ressources' '{' ressources+=Ressource ( "," ressources+=Ressource)* '}' )?
	'}';

ProcessElement returns ProcessElement:
	WorkDefinition | WorkSequence | Guidance;

EString returns ecore::EString:
	STRING | ID;

Ressource returns Ressource:
	'Ressource'
	'{'
		'Name' Name=EString
		('nbOccurance' nbOccurance=EInt)?
	'}';

WorkDefinition returns WorkDefinition:
	{WorkDefinition}
	'WorkDefinition'
	name=EString
	'{'
		('linksToPredecessors' '(' linksToPredecessors+=[WorkSequence|EString] ( "," linksToPredecessors+=[WorkSequence|EString])* ')' )?
		('linksToSuccessors' '(' linksToSuccessors+=[WorkSequence|EString] ( "," linksToSuccessors+=[WorkSequence|EString])* ')' )?
		('parametres' '{' parametres+=parametre ( "," parametres+=parametre)* '}' )?
	'}';

WorkSequence returns WorkSequence:
	'WorkSequence'
	'{'
		'linkType' linkType=WorkSequenceType
		'predecessor' predecessor=[WorkDefinition|EString]
		'successor' successor=[WorkDefinition|EString]
	'}';

Guidance returns Guidance:
	'Guidance'
	'{'
		'text' text=EString
		('elements' '(' elements+=[ProcessElement|EString] ( "," elements+=[ProcessElement|EString])* ')' )?
	'}';

parametre returns parametre:
	'parametre'
	'{'
		('Qte' Qte=EInt)?
		'ressource' ressource=[Ressource|EString]
	'}';

EInt returns ecore::EInt:
	'-'? INT;

enum WorkSequenceType returns WorkSequenceType:
				startToStart = 'startToStart' | finishToStart = 'finishToStart' | startToFinish = 'startToFinish' | finishToFinish = 'finishToFinish';

```
## ATL 语法
**OclType operations**

OclType类相当于由OCL指定的类型实例的定义，它与特定的OCL操作allInstances()相关。  
`allInstances() `：无参数，返回self的所有实例的集合。  
`allInstancesFrom(model : String) `：用于获取给定元模型包含的self的所有实例的集合。  


**OclAny operations**

这部分描述了所有数据类型的一系列通用操作。  
语法结构：
`self.operation_name(parameters)`

被ATL支持的OCL定义的操作：
比较操作：=, <>;  
`oclIsUndefined() `：判定 self 是否是未定义的，返回布尔值;  
`oclIsKindOf(t : oclType) `：判断self 是否是t类型或t的子类型的数据类型，返回布尔值。  
`oclIsTypeOf(t : oclType) `：判断调用者是否是 t类型的实例，返回布尔值，用法类似Java中的instanceof。  
	注意：OCL定义的oclIsNew() 和 oclAsType()是不被ATL引擎支持的。

但是，ATL实现了大量的额外操作：  
`toString() `：返回self的字符串表示，某些类型可能返回与此类型不相关的字符串值。
`oclType() `：返回self的数据类型。  
`asSequence()`, `asSet()`, `asBag()` 返回含有self的sequence、set 、bag 。  
`output(s : String) `向eclipse控制台输出字符，无返回值，仅能用在ATL imperative blocks中。  
`debug(s : String)`返回self的值，并向eclipse控制台输出格式为“s : self_value”的字符串。  
`refSetValue(name : String, val : oclAny)`设置可以用name_value对识别的self的特征，并返回self本身。  
`refGetValue(name : String) `通过name获得self含有的name_value对的value，并返回value。  
`refImmediateComposite() `返回self的直接组合，比如self的直接容器。  
`refInvokeOperation(opName : String, args : Sequence)`通过反射方式调用self的名叫opName的操作，并传递给它包含在args中的若干参数。

## SimplePDL2PetriNet.atl
```
module SimplePDL2PetriNet;
create OUT: petrinet from  IN: simplepdl;

-- Get the process that contains this process element.
-- Note: This helper would not be useful if a reference opposite
-- had been placed between Process and ProcessElement 

helper context simplepdl!ProcessElement
def: getProcess(): simplepdl!Process =
	simplepdl!Process.allInstances()
		->select(p | p.processElements->includes(self))
		->asSequence()->first();

helper context simplepdl!Process
def: nodeOfPetriNet(): petrinet!Node =
	petrinet!Node.allInstances() -> asSequence();

helper context simplepdl!Process
def: arcOfPetriNet(): petrinet!Arc =
	petrinet!Arc.allInstances() -> asSequence();

-- Translate a Process into a PetriNet of the same name
rule Process2PetriNet {
	from p: simplepdl!Process
	to pn: petrinet!PetriNet (
		name <- p.name,
		nodes <- p.nodeOfPetriNet(),
		arcs <- p.arcOfPetriNet())
}

-- Translate a Work Definition into a pattern on the PetriNet
rule WorkDefinition2PetriNet {
	from wd: simplepdl!WorkDefinition
	to
		-- PLACES d'une WorkDefinition
		p_ready: petrinet!Place(
				name <- wd.name + '_ready',
				jeton <- 1),
				
		p_running: petrinet!Place(
				name <- wd.name + '_running',
				jeton <- 0),
				
		p_started: petrinet!Place(
				name <- wd.name + '_started',
				jeton <- 0),
				
		p_finished: petrinet!Place(
				name <- wd.name + '_finished',
				jeton <- 0),
				
		-- TRANSITION d'une WorkDefinition
		tr_start:petrinet!Transition(
				name <- wd.name + '_start'),
				
		tr_finish:petrinet!Transition(
				name <- wd.name + '_finish'),
				
		-- ARC d'une WorkSequence
		arc1 : petrinet!Arc (type <- #normal, source <- p_ready, target <- tr_start),
		arc21 : petrinet!Arc (type <- #normal, source <- tr_start, target <- p_running),
		arc22 : petrinet!Arc (type <- #normal, source <- tr_start, target <- p_started),
		arc3 : petrinet!Arc (type <- #normal, source <- p_running, target <- tr_finish),
		arc4 : petrinet!Arc (type <- #normal, source <- tr_finish, target <- p_finished)
		
}

rule WorkSequence2PetriNet {
	from ws: simplepdl!WorkSequence
	to
		-- ARCs d'une WorkSequence
		arcWS : petrinet!Arc (
			type <- #read_arc,
			poid <- 1,
			source <- thisModule.resolveTemp(ws.predecessor,
				if ((ws.linkType = #finishToFinish) or (ws.linkType = #finishToStart))
					then 'p_finished'
					else 'p_started'
					endif),
			target <- thisModule.resolveTemp(ws.successor,
				if ((ws.linkType = #finishToStart) or (ws.linkType = #startToStart))
					then 'tr_start'
					else 'tr_finish'
					endif))
}

-- Ajouter la transformation des ressources .....

rule Ressource2PetriNet {
	from res: simplepdl!Ressource
	to p_res: petrinet!Place(
		name <- res.Name,
		jeton <- res.nbOccurance)
}

helper context simplepdl!parametre
def: wdOfPar(): simplepdl!WorkDefinition =
	let allWD : Sequence(simplepdl!WorkDefinition) = 
		simplepdl!WorkDefinition.allInstances() -> asSequence() in
		allWD -> select(e|e.parametres -> includes(self)) -> first();
	
	
rule Parameter2PetriNet {
	-- Comme le prof. a dit "RU2PN"
	from par : simplepdl!parametre
	to 
		arc_take : petrinet!Arc(
			type <- #normal,
			poid <- par.Qte,
			source <- par.ressource,
			target <- thisModule.resolveTemp(par.wdOfPar(),'tr_start')
		),
		
		arc_giveBack : petrinet!Arc (
			type <- #normal,
			poid <- par.Qte,
			source <- par.ressource,
			target <- thisModule.resolveTemp(par.wdOfPar(),'tr_finish')
		)
}
```